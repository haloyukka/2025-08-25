# 負荷試験用ダミーデータ生成

データベースへの負荷試験を実施するためにダミーデータを生成する仕組みを構築したい。
その回答を得るために必要な情報をこちらに質問してください。
十分な情報を得たら、回答を作成してください。

## 環境
- Google Cloud SQL
- MySQL
- ストアド・プロシージャ
## 要件

### テーブル構成

- 主要テーブル間の関係図
	- HistoryMainline を中心に各テーブルが接続されている。

- 主なリレーション：
	- Container.ContainerId → HistoryMainline.ContainerId
	- DataPointHistory.HistoryMainlineId → HistoryMainline.HistoryMainlineId
	- DataPointHistoryDetail.DataPointHistoryId → DataPointHistory.DataPointHistoryId
	- isOEERawDetails.HistoryMainlineId → HistoryMainline.HistoryMainlineId
	- ResourceStatusHistory.HistoryMainlineId → HistoryMainline.HistoryMainlineId

### テーブル定義
```SQL
create table [dbo].[Container] (  
  [BatchComments] nvarchar(2000)  
  , [BatchId] char(16)  
  , [BatchStatus] int  
  , [BillOfProcessId] char(16)  
  , [BinSize] nvarchar(100)  
  , [BOMId] char(16)  
  , [CDOTypeId] int  
  , [ChangeCount] int  
  , [ChildCount] int  
  , [ConsumingOrder] nvarchar(255)  
  , [ContainerComments] nvarchar(2000)  
  , [ContainerId] char(16) not null  
  , [ContainerName] nvarchar(30)  
  , [ContainerStartGUID] nvarchar(40)  
  , [CurrentHoldCount] int  
  , [CurrentStatusId] char(16)  
  , [CurrentThruputChildCount] int  
  , [CurrentThruputQty] float(53)  
  , [CurrentThruputQty2] float(53)  
  , [CurrentThruputUnitCount] int  
  , [CustomerId] char(16)  
  , [DateCode] nvarchar(100)  
  , [Description] nvarchar(255)  
  , [DetailId] char(16)  
  , [Direction] int  
  , [DueDate] datetime  
  , [DueDateGMT] datetime  
  , [ExpirationDate] datetime  
  , [ExpirationDateGMT] datetime  
  , [FactoryStartDate] datetime  
  , [FactoryStartDateGMT] datetime  
  , [FactoryStartQty] float(53)  
  , [FactoryStartQty2] float(53)  
  , [FactoryStartUOM2Id] char(16)  
  , [FactoryStartUOMId] char(16)  
  , [HoldReasonId] char(16)  
  , [InQualityControl] int  
  , [IssuedToContainerId] char(16)  
  , [LastActivityDate] datetime  
  , [LastActivityDateGMT] datetime  
  , [LastCarrierId] char(16)  
  , [LastCompletionDate] datetime  
  , [LastCompletionDateGMT] datetime  
  , [LastRevTxnId] char(16)  
  , [LeadFree] int  
  , [LevelId] char(16)  
  , [MasterRecipeId] char(16)  
  , [MfgOrderId] char(16)  
  , [MfgPartNumber] nvarchar(100)  
  , [NickName] nvarchar(100)  
  , [OnHoldDate] datetime  
  , [OriginalContainerId] char(16)  
  , [OriginalFactoryId] char(16)  
  , [OriginalQty] float(53)  
  , [OriginalQty2] float(53)  
  , [OriginalStartDate] datetime  
  , [OriginalStartDateGMT] datetime  
  , [OriginalUOM2Id] char(16)  
  , [OriginalUOMId] char(16)  
  , [OwnerId] char(16)  
  , [ParentContainerId] char(16)  
  , [PlannedProductId] char(16)  
  , [PlannedQty] float(53)  
  , [PlannedQty2] float(53)  
  , [PlannedQtyUOM2Id] char(16)  
  , [PlannedQtyUOMId] char(16)  
  , [PlannedStartDate] datetime  
  , [PlannedStartDateGMT] datetime  
  , [PriorityCodeId] char(16)  
  , [ProductId] char(16)  
  , [ProductionComplete] bit not null  
  , [Qty] float(53)  
  , [Qty2] float(53)  
  , [RelativePriority] int  
  , [RequestDate] datetime  
  , [RequestDateGMT] datetime  
  , [SalesOrderId] char(16)  
  , [SamplingLotId] char(16)  
  , [SamplingPassed] bit not null  
  , [SamplingRequired] bit not null  
  , [ShapeName] nvarchar(255)  
  , [SPCChartSaveOptionsEnumId] char(16)  
  , [SpecStatusId] char(16)  
  , [SplitFromId] char(16)  
  , [StartParentContainerId] char(16)  
  , [StartReasonId] char(16)  
  , [Status] int  
  , [Supplier] nvarchar(100)  
  , [SupplyFromName] nvarchar(100)  
  , [SupplyFromType] nvarchar(255)  
  , [ThisContainerLost] bit not null  
  , [ThruputAdjustmentChildCount] int  
  , [ThruputAdjustmentQty] float(53)  
  , [ThruputAdjustmentQty2] float(53)  
  , [ThruputAdjustmentUnitCount] int  
  , [UnitCount] int  
  , [UOM2Id] char(16)  
  , [UOMId] char(16)  
  , [VendorItemId] char(16)  
  , [WIPMsgDefMgrId] char(16)  
  , [bpCalculateQtyRequired] bit not null  
  , [DeviceIdentifierId] char(16)  
  , [isAssociatedCarrierId] char(16)  
  , [isAutoStart] bit not null  
  , [isCarrier] bit not null  
  , [isCarrierSlot] int  
  , [isFailed] bit not null  
  , [isHoldReasonName] nvarchar(30)  
  , [isInventoryLocationId] char(16)  
  , [isMaterialManageEnabled] bit not null  
  , [isProductName] nvarchar(30)  
  , [isProductRevision] nvarchar(15)  
  , [isRepairedDefectCount] int  
  , [ManufacturingDate] datetime  
  , [ManufacturingDateGMT] datetime  
  , [ProductionIdentifier] nvarchar(100)  
  , UDI nvarchar(1000)  
  , primary key (ContainerId)  
);
```

---

```SQL
create table [dbo].[HistoryMainline] (  
  [Application] int  
  , [BaseTxnType] int  
  , [BatchId] char(16)  
  , [BinningIncluded] bit not null  
  , [BonusIncluded] bit not null  
  , [CalendarShiftId] char(16)  
  , [CarrierId] char(16)  
  , [CDOTypeId] int  
  , [ChangeCount] int  
  , [Client] int  
  , [Comments] nvarchar(255)  
  , [CompoundTxnType] int  
  , [ComputationHistoryId] char(16)  
  , [ContainerId] char(16)  
  , [DefectIncluded] bit not null  
  , [EmployeeId] char(16)  
  , [ESigRequirementId] char(16)  
  , [FactoryId] char(16)  
  , [HistoryId] char(16)  
  , [HistoryMainlineId] char(16) not null  
  , [IconId] int  
  , [Implicit] bit not null  
  , [InRework] bit not null  
  , [LocalReworkIncluded] bit not null  
  , [LoginId] char(16)  
  , [LossIncluded] bit not null  
  , [MfgDate] datetime  
  , [MfgProcessOverridesId] char(16)  
  , [OperationId] char(16)  
  , [OwnerId] char(16)  
  , [ParametricDetailId] char(16)  
  , [ProductId] char(16)  
  , [QualityESigConfirmed] bit not null  
  , [ResourceAvailability] int  
  , [ResourceId] char(16)  
  , [ResourceStatusCodeId] char(16)  
  , [ResourceStatusReasonId] char(16)  
  , [ReversalStatus] int  
  , [Server] int  
  , [ShiftName] nvarchar(30)  
  , [SpecId] char(16)  
  , [Status] int  
  , [StepEntryTxnId] char(16)  
  , [StepPass] int  
  , [SystemDate] datetime  
  , [SystemDateGMT] datetime  
  , [TxnDate] datetime  
  , [TxnDateGMT] datetime  
  , [TxnId] char(16)  
  , [TxnServiceName] nvarchar(32)  
  , [TxnServiceSequence] int  
  , [TxnType] int  
  , [UserId] char(16)  
  , [WorkflowStepId] char(16)  
  , [WorkstationId] char(16)  
  , [CIOMessageID] nvarchar(36)  
  , [CIOMessageIDOutbound] nvarchar(36)  
  , [DeviceIdentifierId] char(16)  
  , [ExpirationDate] datetime  
  , [ExpirationDateGMT] datetime  
  , [isFailed] bit not null  
  , [ManufacturingDate] datetime  
  , [ManufacturingDateGMT] datetime  
  , [ProductionIdentifier] nvarchar(100)  
  , UDI nvarchar(100)  
  , primary key (HistoryMainlineId)  
);
```


---

```SQL
create table [dbo].[DataPointHistory] (  
  [CDOTypeId] int  
  , [ChangeCount] int  
  , [DataCollectionDefId] char(16)  
  , [DataPointHistoryId] char(16) not null  
  , [ExportImportKey] nvarchar(36)  
  , [HistoryId] char(16)  
  , [HistoryMainlineId] char(16)  
  , [TxnId] char(16)  
  , primary key (DataPointHistoryId)  
);
```

---

```SQL
create table [dbo].[DataPointHistoryDetail] (  
  [AttributeName] nvarchar(255)  
  , [BooleanValue] bit not null  
  , [CDOTypeId] int  
  , [ChangeCount] int  
  , [Comments] nvarchar(2000)  
  , [DataCollectionDefId] char(16)  
  , [DataName] nvarchar(30)  
  , [DataPointHistoryDetailId] char(16) not null  
  , [DataPointHistoryId] char(16)  
  , [DataPointId] char(16)  
  , [DataType] int  
  , [DataValue] nvarchar(30)  
  , [DecimalScale] int  
  , [DecimalValue] decimal(19, 9)  
  , [EnumerationValue] nvarchar(30)  
  , [ExportImportKey] nvarchar(36)  
  , [FixedValue] float(53)  
  , [FloatValue] float(53)  
  , [HistoryId] char(16)  
  , [IntegerValue] int  
  , [IsLimitOverride] bit not null  
  , [IsLimitOverrideAllowed] bit not null  
  , [IsLimitViolation] bit not null  
  , [IsRequired] bit not null  
  , [LowerLimit] nvarchar(30)  
  , [MapToUserAttribute] bit not null  
  , [NDOValueId] char(16)  
  , [ObjectTypeName] nvarchar(30)  
  , [OriginalValue] nvarchar(30)  
  , [RDOValueId] char(16)  
  , [TimestampValue] datetime  
  , [TxnId] char(16)  
  , [UOMId] char(16)  
  , [UpperLimit] nvarchar(30)  
  , [isDefectReasonId] char(16)  
  , [isRequireDefectReason] bit not null  
  , primary key (DataPointHistoryDetailId)  
);
```

---

```SQL
create table [dbo].[isOEERawDetails] (  
  [CalendarDate] datetime  
  , [CalendarShiftId] char(16)  
  , [CDOTypeId] int  
  , [ChangeCount] int  
  , [ChildCount] int  
  , [ContainerId] char(16)  
  , [ContainerName] nvarchar(30)  
  , [CycleStartGMT] datetime  
  , [CycleTime] float(53)  
  , [EmployeeId] char(16)  
  , [EmployeeName] nvarchar(30)  
  , [EquipmentCycleTimeMS] float(53)  
  , [FactoryId] char(16)  
  , [FactoryName] nvarchar(30)  
  , [GoodQty] float(53)  
  , [GoodQty2] float(53)  
  , [HistoryMainlineId] char(16)  
  , [IdealCycleTime] float(53)  
  , [isERPOperation] nvarchar(30)  
  , [isFailed] bit not null  
  , [isFailedQty] float(53)  
  , [isOEERawDetailsId] char(16) not null  
  , [isOEERawDetailsName] nvarchar(36)  
  , [isOpenDefectCount] int  
  , [isQty] float(53)  
  , [isRecipeName] nvarchar(100)  
  , [isRepairedDefectCount] int  
  , [isRouteStepName] nvarchar(30)  
  , [isTotalDefectCount] int  
  , [LossQty] float(53)  
  , [LossQty2] float(53)  
  , [MfgOrderId] char(16)  
  , [MfgOrderName] nvarchar(30)  
  , [OperationId] char(16)  
  , [OperationName] nvarchar(30)  
  , [OwnerName] nvarchar(30)  
  , [ParentId] char(16)  
  , [ProcessTime] float(53)  
  , [ProductFamilyId] char(16)  
  , [ProductFamilyName] nvarchar(30)  
  , [ProductId] char(16)  
  , [ProductName] nvarchar(30)  
  , [ProductRevision] nvarchar(15)  
  , [QtyAdjustReason] nvarchar(30)  
  , [QueueTime] float(53)  
  , [RecipeId] char(16)  
  , [RecipeName] nvarchar(100)  
  , [ResourceFamilyId] char(16)  
  , [ResourceFamilyName] nvarchar(30)  
  , [ResourceId] char(16)  
  , [ResourceName] nvarchar(30)  
  , [ReworkedQty] float(53)  
  , [ReworkedQty2] float(53)  
  , [ReworkReason] nvarchar(30)  
  , [RouteStepId] char(16)  
  , [Shift] nvarchar(30)  
  , [SpecId] char(16)  
  , [SpecName] nvarchar(30)  
  , [SpecRevision] nvarchar(15)  
  , [StartParentContainerId] char(16)  
  , [StepId] char(16)  
  , [StepName] nvarchar(30)  
  , [StepPass] int  
  , [TotalQty] float(53)  
  , [TotalQty2] float(53)  
  , [TxnDate] datetime  
  , [TxnDateGMT] datetime  
  , [TxnName] nvarchar(2000)  
  , [TxnType] int  
  , UOM nvarchar(30)  
  , UOM2 nvarchar(30)  
  , [WorkflowId] char(16)  
  , [WorkflowName] nvarchar(30)  
  , [WorkflowRevision] nvarchar(15)  
  , [WorkflowStepSequence] int  
  , primary key (isOEERawDetailsId)  
);
```

---

```SQL
create table [dbo].[ResourceStatusHistory] (  
  [Availability] int  
  , [CDOTypeId] int  
  , [ChangeCount] int  
  , [Comments] nvarchar(2000)  
  , [ExportImportKey] nvarchar(36)  
  , [HistoryId] char(16)  
  , [HistoryMainlineId] char(16)  
  , [LastStatusChangeDate] datetime  
  , [LastStatusChangeDateGMT] datetime  
  , [OldAvailability] int  
  , [OldComments] nvarchar(2000)  
  , [OldLastActivityDate] datetime  
  , [OldLastActivityDateGMT] datetime  
  , [OldLastStatusChangeDate] datetime  
  , [OldLastStatusChangeDateGMT] datetime  
  , [OldPartExpiryDate] datetime  
  , [OldPartQty] int  
  , [OldPhysicalLocationId] char(16)  
  , [OldPhysicalPositionId] char(16)  
  , [OldProductId] char(16)  
  , [OldResourceState] int  
  , [OldResourceStatusCodeId] char(16)  
  , [OldResourceStatusReasonCodeId] char(16)  
  , [OldRun] nvarchar(30)  
  , [OldSetupId] char(16)  
  , [OldUpdateLastStatusChangeDate] int  
  , [PartExpiryDate] datetime  
  , [PartQty] int  
  , [PhysicalLocationId] char(16)  
  , [PhysicalPositionId] char(16)  
  , [ProductId] char(16)  
  , [ResourceState] int  
  , [ResourceStatusCodeId] char(16)  
  , [ResourceStatusHistoryId] char(16) not null  
  , [ResourceStatusReasonCodeId] char(16)  
  , [Run] nvarchar(30)  
  , [SetupId] char(16)  
  , [ss_NewLocationId] char(16)  
  , [ss_OldLocationId] char(16)  
  , [TxnId] char(16)  
  , [UpdateLastStatusChangeDate] int  
  , [isOEELossCategory] int  
  , [isOldOEELossCategory] int  
  , [isRecipeId] char(16)  
  , primary key (ResourceStatusHistoryId)  
);
```

### 作成したいデータ量

一ヶ月単位でテーブルに格納するレコードを数を徐々に増やしていきたい。

|テーブル名|Container|HistoryMainline|DataPointHistory|DataPointHistoryDetail|isOEERawDetails|ResourceStatusHistory|
|1ヶ月分|81|270,270|270,270|100,000,000|270,270|270,270|
|2ヶ月分|162|540,540|540,540|200,000,000|540,540|540,540|
|3ヶ月分|243|810,810|810,810|300,000,000|810,810|810,810|
|4ヶ月分|324|1,081,080|1,081,080|400,000,000|1,081,080|1,081,080|
|5ヶ月分|405|1,351,350|1,351,350|500,000,000|1,351,350|1,351,350|
|6ヶ月分|486|1,621,620|1,621,620|600,000,000|1,621,620|1,621,620|
|7ヶ月分|567|1,891,890|1,891,890|700,000,000|1,891,890|1,891,890|
|8ヶ月分|648|2,162,160|2,162,160|800,000,000|2,162,160|2,162,160|
|9ヶ月分|729|2,432,430|2,432,430|900,000,000|2,432,430|2,432,430|
|10ヶ月分|810|2,702,700|2,702,700|1,000,000,000|2,702,700|2,702,700|
|11ヶ月分|891|2,972,970|2,972,970|1,100,000,000|2,972,970|2,972,970|
|12ヶ月分|972|3,243,240|3,243,240|1,200,000,000|3,243,240|3,243,240|

---

了解！実装に入る前に、負荷試験データの“意味づけ・量・生成方式・運用”をブレずに決めるため、要点を一気に確認させてください。回答が難しい項目は、（デフォルト案）をそのまま採用してOKです。

# 確認したいこと（回答欄つき）

## 1) Cloud SQL / MySQL の前提

1. MySQLメジャーバージョン（例: 8.0.x）：
2. インスタンスサイズ・ストレージ/IO設定（vCPU/RAM/ストレージタイプと容量、自動拡張の可否）：
3. バイナリログ/ポイントインタイムリカバリ（有効/無効）：（デフォルト案: 無効、生成バッチ時のみOFFにできると安全）
4. InnoDB設定（innodb\_flush\_log\_at\_trx\_commit, buffer pool など）を調整して良いか：可 / 不可
5. リージョン/HA構成（単一AZ / 高可用性 / リードレプリカ有無）：（デフォルト案: 単一AZ・レプリカ無し）

## 2) スキーマ移植方針（SQL Server → MySQL 差異）

6. `NVARCHAR` は MySQL では `VARCHAR(...) CHARACTER SET utf8mb4` に置換で良いか：はい / いいえ
7. `datetime` は MySQL の `DATETIME(3)`（ミリ秒）で良いか：はい / いいえ（デフォルト案: DATETIME(3)）
8. スキーマ修正の許容度（NOT NULLやDEFAULT、INDEX/PK/UKの追加可否）：（デフォルト案: 性能のため適切に追加可）

## 3) 主キー/IDの仕様

9. `char(16)` のIDは**どう生成**しますか？

   * A) 固定長16のBase36/64文字列
   * B) UUIDの圧縮表現（例: UUID→BINARY(16)→Base32/64化）
   * C) MySQLの`BINARY(16)`で生UUID保存
   * D) オートインクリメント
     （デフォルト案: 参照整合と性能のため `BINARY(16)`のUUIDを主キー、表示時はHEX）
10. 既存の `Container.ContainerId` など**外部参照は同一方式**で統一して良いか：はい / いいえ

## 4) 参照整合・件数比率（超重要）

11. 1 `HistoryMainline` あたりの

    * 関連 `DataPointHistory` の件数分布（平均/最大）：（デフォルト案: 平均1, 最大3）
    * 1 `DataPointHistory` あたり `DataPointHistoryDetail` の件数分布：
      → 100M/月を満たすための比率をどう置くか（デフォルト案: Detailはセンサー属性10〜40個/ポイントで広い分布）
12. `isOEERawDetails` と `ResourceStatusHistory` は `HistoryMainline` と**1:1 / 1:多 / 多:多**どれにしますか？（デフォルト案: それぞれ1:1〜1:数件の疎分布）
13. `Container` と `HistoryMainline` の関係（1コンテナに対し履歴N件）で平均/最大N：（デフォルト案: 平均 300、最大 1,000）

## 5) 日付の分布・増加させ方

14. 「1ヶ月単位で徐々に増やす」の**意味**：

* A) 月ごとに**追加挿入**して総量を増やす
* B) 各月のデータ量自体が逓増（後の月ほど多い）
* C) 指定表の**累計**が目標（提示表は累計に見えます）
  （デフォルト案: **累計**目標。月次ジョブが差分を追加し、総量が表の値に到達）

15. タイムスタンプは**実カレンダー日付**に合わせて一様分布／勤務シフトに寄せるなどの**季節性**を付けますか？（デフォルト案: 稼働時間帯(例: 08:00-20:00)に寄せ、週末は20%量に抑制）
16. タイムゾーンはJST固定でOK？GMT列はJST→UTC変換して保存？（デフォルト案: JST→UTC変換してGMT列に格納）

## 6) 値ドメイン（現実味・分布）

17. 代表的なID/Name系（Factory/Operation/Product/Spec/Resourceなど）の**マスタ値候補**は提供可能？
    → 無ければ擬似マスタを生成（件数目安もください。例: 工場=3, ライン=20, 装置=200, 製品=1,000 など）
18. OEE/品質系の**GoodQty/LossQty/IdealCycleTime**等の分布（平均・ばらつき・相関）：（デフォルト案: 正規分布±外れ値、装置/製品で母数切替）
19. `Enumeration`/`Boolean`/`DataType`/`UOM` 等の**取りうる値セット**：
    → 決まっていなければ汎用セットを用意

## 7) 物理設計（性能/運用）

20. パーティショニング方針：

* A) 月次レンジ（推奨）
* B) 週次レンジ
* C) ハッシュ（ID）
  （デフォルト案: **月次レンジ** on `TxnDate`/`SystemDate`、巨大表はサブパーティションIDハッシュ）

21. 主要インデックス：クエリ想定（例: 期間×Resource/Container、外部参照Join、明細検索キー）を教えてください。
    （デフォルト案: FK/参照列＋ `TxnDate`,`HistoryMainlineId` に複合索引）
22. ストレージ節約のため**圧縮**（MySQL行圧縮/ページ圧縮相当）や `ZSTD`で**外部CSV**を併用する発想は可？（デフォルト案: 可）
23. **投入方式の縛り**：完全に**ストアドのみ**／サーバ側SQL＋ `LOAD DATA` 併用OK？（1.2B行規模は `LOAD DATA` 併用を強く推奨）
24. ジョブ実行方式：

* A) MySQL EVENT（スケジューラ）
* B) Cloud Run / Cloud Functions からストアド呼出
* C) 手動実行
  （デフォルト案: Cloud Run バッチ → ストアド呼出、再実行可能な**月次単位**設計）

25. モニタリング/KPI：挿入TPS、ロック待ち、Redo/バッファヒット、表/索引サイズ、失敗リトライ戦略の閾値は？（デフォルト案: ダッシュボードとしきい値は経験則から提案）

## 8) コスト・安全

26. テスト期間・最大到達月（例: 12ヶ月累計まで）と、その後の**一括削除/切替**は必要？（デフォルト案: パーティションDROPで月次削除可能に）
27. 誤投入防止（本番混入防止）のため**専用スキーマ & 接頭辞**で運用して良いか：はい / いいえ

---

# 次のステップ（こちらで実施内容）

ご回答を受けて、以下を**一式**でお渡しします（MySQL用に最適化）。

* **DDL**（MySQL互換・文字セット/PK/FK/INDEX/パーティションを含む）
* **ダミーマスタ生成**ストアド（Factory/Resource/Product等）
* **月次データ生成**ストアド（依存関係を守りつつ、テーブル間比率・分布を再現）
* **高速バルクローダ**（`LOAD DATA` 併用版＆純ストアド版の2系統）
* **運用スクリプト**（月次追加・ロールバック・パーティション管理・進捗ログ）
* **性能チューニング指針**（パラメータ、インデックス、バッチ粒度、再実行性）
* **安全対策**（専用スキーマ、フェイルセーフ、誤投入防止）

まずは上記の質問にざっとお答えください。回答が揃い次第、即座に設計と実装案（SQL一式）を提示します。

---

一旦、ここまでの内容で作成してください。

---

了解。こちらで前提を“デフォルト案”に固定し、**Cloud SQL for MySQL 8.0**前提の「月次で増やす大型ダミーデータ生成スイート（ストアド中心／大規模でも実用速度）」を一式で用意しました。
そのままコピペ実行できるよう、以下の順で提示します。

1. 前提・方針（ここで固定）
2. スキーマ&ヘルパー（カウンタ/数表/ユーティリティ関数）
3. 生成プロシージャ（マスタ／月次データ／巨大明細の分割投入）
4. 使用手順（1～12ヶ月まで一括生成コマンド付き）
5. 運用の要点（パーティション/監視/ロールバック）

---

# 1) 前提・方針（確定）

* **MySQL 8.0 / InnoDB / utf8mb4**。
* 文字列列は `NVARCHAR`→`VARCHAR(...) CHARACTER SET utf8mb4`、`BIT`→`TINYINT(1)`、`float(53)`→`DOUBLE`、`datetime`→`DATETIME(3)`。
* 既存DDLの**列は基本そのまま**（型だけMySQL相当に変換）。
* 主キー/外部キーは提示どおり（`CHAR(16)`のIDを\*\*Base36の連番（16桁左パディング）\*\*で一意生成）。
* **月次で累計が増える**運用（1ヶ月=表の1行目、…12ヶ月=表の12行目）。
* 巨大表（特に `DataPointHistoryDetail`）は**月次レンジ・パーティション**（`TimestampValue`/`TxnDate`基準）。
* **完全ストアドだけで動作**します（外部ファイル不要）。パフォーマンス確保のため**数表（1,000行）×集合演算**で一括挿入、**分割バッチ**を採用。

> 生成件数（累計目標）
>
> * Container … 81 × 月数
> * HistoryMainline … 270,270 × 月数
> * DataPointHistory … 270,270 × 月数（HMと同数・1:1想定）
> * **DataPointHistoryDetail … 100,000,000 × 月数**
> * isOEERawDetails … 270,270 × 月数（HMと1:1想定）
> * ResourceStatusHistory … 270,270 × 月数（HMと1:1想定）

---

# 2) スキーマ & ヘルパー

> 既存のテーブル定義はそのまま活かせます（Microsoft SQL Server 風→MySQL相当型）。
> 既に作成済みなら **2.3 以降だけ**実行してください。

```sql
-- 2.1 スキーマ
CREATE SCHEMA IF NOT EXISTS loadtest DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;
USE loadtest;

-- 2.2 既存テーブルに対する簡易想定（型マッピングのみ例示）
-- ※ 実運用では、提示DDLの全列を MySQL 相当に変換してください。
--   例：NVARCHAR -> VARCHAR(... ) CHARACTER SET utf8mb4, BIT -> TINYINT(1), datetime -> DATETIME(3), float(53) -> DOUBLE
--   主キー/外部キーは提示の通り（CHAR(16)）で作成。
--   ここでは外部参照に必要な列を使うこと前提でジェネレータを構成します。

-- 2.3 生成ユーティリティ：連番カウンタ（各テーブルのID払い出し）
CREATE TABLE IF NOT EXISTS surrogate_counters (
  table_name VARCHAR(64) PRIMARY KEY,
  next_id BIGINT UNSIGNED NOT NULL
) ENGINE=InnoDB;

INSERT IGNORE INTO surrogate_counters (table_name, next_id) VALUES
 ('Container', 1), ('HistoryMainline', 1), ('DataPointHistory', 1),
 ('DataPointHistoryDetail', 1), ('isOEERawDetails', 1), ('ResourceStatusHistory', 1);

-- 2.4 数表（1,000行）
CREATE TABLE IF NOT EXISTS seq_1k (
  n INT PRIMARY KEY
) ENGINE=InnoDB;

WITH RECURSIVE seq AS (
  SELECT 0 n
  UNION ALL
  SELECT n+1 FROM seq WHERE n < 999
)
INSERT IGNORE INTO seq_1k (n) SELECT n FROM seq;

-- 2.5 Base36変換（ID生成用）
DROP FUNCTION IF EXISTS to_base36;
DELIMITER $$
CREATE FUNCTION to_base36(n BIGINT UNSIGNED)
RETURNS VARCHAR(32) DETERMINISTIC
BEGIN
  DECLARE s VARCHAR(32) DEFAULT '';
  DECLARE r INT;
  IF n = 0 THEN RETURN '0'; END IF;
  WHILE n > 0 DO
    SET r = n % 36;
    SET s = CONCAT(SUBSTRING('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', r + 1, 1), s);
    SET n = FLOOR(n / 36);
  END WHILE;
  RETURN s;
END$$
DELIMITER ;

-- 2.6 ID16（左0詰め16桁 Base36）
DROP FUNCTION IF EXISTS id16_from_counter;
DELIMITER $$
CREATE FUNCTION id16_from_counter(base_id BIGINT UNSIGNED, off BIGINT UNSIGNED)
RETURNS CHAR(16) DETERMINISTIC
BEGIN
  RETURN LPAD(to_base36(base_id + off), 16, '0');
END$$
DELIMITER ;

-- 2.7 ランダム日時（[start,end) の一様分布）
DROP FUNCTION IF EXISTS random_datetime_between;
DELIMITER $$
CREATE FUNCTION random_datetime_between(start_dt DATETIME(3), end_dt DATETIME(3))
RETURNS DATETIME(3) DETERMINISTIC
BEGIN
  DECLARE sec BIGINT;
  DECLARE ms INT;
  SET sec = TIMESTAMPDIFF(SECOND, start_dt, end_dt);
  IF sec <= 0 THEN RETURN start_dt; END IF;
  SET ms = FLOOR(RAND() * 1000);
  RETURN start_dt + INTERVAL FLOOR(RAND()*sec) SECOND + INTERVAL ms MICROSECOND*1000;
END$$
DELIMITER ;

-- 2.8 カウンタからバッチ払い出し（IDの連番確保）
DROP PROCEDURE IF EXISTS take_id_batch;
DELIMITER $$
CREATE PROCEDURE take_id_batch(IN p_table VARCHAR(64), IN p_size BIGINT UNSIGNED, OUT p_start BIGINT UNSIGNED)
BEGIN
  START TRANSACTION;
    SELECT next_id INTO p_start FROM surrogate_counters WHERE table_name = p_table FOR UPDATE;
    UPDATE surrogate_counters SET next_id = next_id + p_size WHERE table_name = p_table;
  COMMIT;
END$$
DELIMITER ;
```

> （任意・推奨）`HistoryMainline`, `DataPointHistoryDetail`, `isOEERawDetails`, `ResourceStatusHistory` に **月次パーティション**を設定してください（新規作成時が簡単）。既存テーブルの場合は一旦空にして `PARTITION BY RANGE COLUMNS(...)` で再作成するのが確実です。

---

# 3) 生成プロシージャ群

> 目的：**月の開始日**（例：`2025-01-01`）を起点に、「その月の追加分」を一気に作る。
> 巨大明細（`DataPointHistoryDetail`）は**分割バッチ**で投入します（例：10M行×10回＝100M行/月）。

**3.1 マスタの軽量生成（ダミー）**
工場/リソース/製品などの名前系は必要最低限を作ります（NULL許容列はNULLで可）。既に実マスタがある場合はスキップしてください。

```sql
DROP PROCEDURE IF EXISTS seed_masters;
DELIMITER $$
CREATE PROCEDURE seed_masters()
BEGIN
  -- 例：最小限のダミー行が必要な場合（存在しないと困る列名がある場合のみ）
  -- 今回は明示マスタ表が提示されていないためスキップ可能なダミー（必要に応じて拡張してください）。
  SELECT 'masters: nothing to seed (using NULL/defaults) — extend here if you have dimension tables.' AS info;
END$$
DELIMITER ;
```

**3.2 月次データ生成本体**

* `p_month_start`: その月の1日（`DATE`）
* 目標件数は仕様表に基づく固定式（`×月数`ではなく**その月の追加分**を与えます）。
* **引数で件数を明示**できるようにもしておきます（柔軟性）。

```sql
-- 月次の目標件数（このプロシージャは "その月の追加分" を作成）
DROP PROCEDURE IF EXISTS generate_month;
DELIMITER $$
CREATE PROCEDURE generate_month(
    IN p_month_start DATE,
    IN p_container INT,
    IN p_hm BIGINT,
    IN p_dph BIGINT,
    IN p_dphd BIGINT,
    IN p_oee BIGINT,
    IN p_rsh BIGINT
)
BEGIN
  DECLARE v_start_dt DATETIME(3);
  DECLARE v_end_dt   DATETIME(3);
  DECLARE v_days INT;

  SET v_start_dt = CONCAT(p_month_start, ' 00:00:00.000');
  SET v_end_dt   = CONCAT(LAST_DAY(p_month_start), ' 23:59:59.999');
  SET v_days     = DAY(LAST_DAY(p_month_start));

  /* ===== 1) Container ===== */
  IF p_container > 0 THEN
    DECLARE v_c_start BIGINT UNSIGNED;
    CALL take_id_batch('Container', p_container, v_c_start);

    INSERT INTO Container (ContainerId, ContainerName, ProductionComplete, SamplingPassed, SamplingRequired,
                           ThisContainerLost, bpCalculateQtyRequired, isAutoStart, isCarrier, isFailed,
                           isMaterialManageEnabled, ManufacturingDate, ManufacturingDateGMT, ProductionIdentifier, UDI)
    SELECT
      id16_from_counter(v_c_start, ROW_NUMBER() OVER(ORDER BY g.n) - 1) AS ContainerId,
      CONCAT('C_', LPAD((ROW_NUMBER() OVER(ORDER BY g.n)), 9, '0')) AS ContainerName,
      0, 1, 0, 0, 0, 0, 0, 0,
      1,
      random_datetime_between(v_start_dt, v_end_dt) AS ManufacturingDate,
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR) AS ManufacturingDateGMT,
      CONCAT('PID-', UUID()) AS ProductionIdentifier,
      CONCAT('UDI-', UUID()) AS UDI
    FROM (
      SELECT n FROM seq_1k
      UNION ALL SELECT n+1000 FROM seq_1k
      UNION ALL SELECT n+2000 FROM seq_1k
    ) g
    LIMIT p_container;
  END IF;

  /* ===== 2) HistoryMainline ===== */
  IF p_hm > 0 THEN
    DECLARE v_hm_start BIGINT UNSIGNED;

    -- Containerの行番号付け（均等に割当）
    WITH c AS (
      SELECT ContainerId,
             ROW_NUMBER() OVER(ORDER BY ContainerId) AS rn,
             (SELECT COUNT(*) FROM Container) AS ctotal
      FROM Container
    )
    SELECT 1 INTO @dummy; -- windowの前にダミー実行（MySQLの実行順対策）

    CALL take_id_batch('HistoryMainline', p_hm, v_hm_start);

    INSERT INTO HistoryMainline (
      HistoryMainlineId, ContainerId, TxnDate, TxnDateGMT, SystemDate, SystemDateGMT,
      Application, Status, TxnType, Client, Server, Comments, isFailed, ManufacturingDate, ManufacturingDateGMT, ProductionIdentifier, UDI
    )
    SELECT
      id16_from_counter(v_hm_start, ROW_NUMBER() OVER(ORDER BY g.n) - 1) AS HistoryMainlineId,
      (SELECT ContainerId FROM (
          SELECT ContainerId, rn, ctotal FROM c
      ) cc WHERE cc.rn = 1 + MOD(ROW_NUMBER() OVER(ORDER BY g.n) - 1, (SELECT ctotal FROM c LIMIT 1))) AS ContainerId,
      random_datetime_between(v_start_dt, v_end_dt) AS TxnDate,
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR) AS TxnDateGMT,
      random_datetime_between(v_start_dt, v_end_dt) AS SystemDate,
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR) AS SystemDateGMT,
      1, 0, 100, 0, 0, 'loadtest', 0,
      random_datetime_between(v_start_dt, v_end_dt) AS ManufacturingDate,
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR) AS ManufacturingDateGMT,
      CONCAT('PID-', UUID()) AS ProductionIdentifier,
      'UDI' AS UDI
    FROM (
      -- 270,270などの数に届くよう、1kテーブルを複数回ユニオン（必要に応じて追加）
      SELECT n FROM seq_1k
      UNION ALL SELECT n+1000 FROM seq_1k
      UNION ALL SELECT n+2000 FROM seq_1k
      UNION ALL SELECT n+3000 FROM seq_1k
      UNION ALL SELECT n+4000 FROM seq_1k
    ) g
    LIMIT p_hm;
  END IF;

  /* ===== 3) DataPointHistory（HMと1:1） ===== */
  IF p_dph > 0 THEN
    DECLARE v_dph_start BIGINT UNSIGNED;
    CALL take_id_batch('DataPointHistory', p_dph, v_dph_start);

    INSERT INTO DataPointHistory (DataPointHistoryId, HistoryMainlineId, CDOTypeId, ChangeCount, DataCollectionDefId, TxnId)
    SELECT
      id16_from_counter(v_dph_start, ROW_NUMBER() OVER(ORDER BY hm.HistoryMainlineId) - 1) AS DataPointHistoryId,
      hm.HistoryMainlineId,
      0, 0, LPAD(HEX(UUID()), 16, '0'), LPAD(HEX(UUID()), 16, '0')
    FROM (
      SELECT HistoryMainlineId
      FROM HistoryMainline
      WHERE TxnDate >= v_start_dt AND TxnDate <= v_end_dt
      ORDER BY HistoryMainlineId
      LIMIT p_dph
    ) hm;
  END IF;

  /* ===== 4) isOEERawDetails（HMと1:1想定） ===== */
  IF p_oee > 0 THEN
    DECLARE v_oee_start BIGINT UNSIGNED;
    CALL take_id_batch('isOEERawDetails', p_oee, v_oee_start);

    INSERT INTO isOEERawDetails (
      isOEERawDetailsId, HistoryMainlineId, TxnDate, TxnDateGMT,
      GoodQty, LossQty, TotalQty, IdealCycleTime, ProcessTime, isFailed
    )
    SELECT
      id16_from_counter(v_oee_start, ROW_NUMBER() OVER(ORDER BY hm.HistoryMainlineId) - 1) AS isOEERawDetailsId,
      hm.HistoryMainlineId,
      random_datetime_between(v_start_dt, v_end_dt),
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR),
      GREATEST(0, ROUND(ABS(RAND()*100),2)),
      GREATEST(0, ROUND(ABS(RAND()*10),2)),
      GREATEST(0, ROUND(ABS(RAND()*110),2)),
      ROUND(ABS(RAND()*1.5),3),
      ROUND(ABS(RAND()*300),3),
      0
    FROM (
      SELECT HistoryMainlineId
      FROM HistoryMainline
      WHERE TxnDate >= v_start_dt AND TxnDate <= v_end_dt
      ORDER BY HistoryMainlineId
      LIMIT p_oee
    ) hm;
  END IF;

  /* ===== 5) ResourceStatusHistory（HMと1:1想定） ===== */
  IF p_rsh > 0 THEN
    DECLARE v_rsh_start BIGINT UNSIGNED;
    CALL take_id_batch('ResourceStatusHistory', p_rsh, v_rsh_start);

    INSERT INTO ResourceStatusHistory (
      ResourceStatusHistoryId, HistoryMainlineId, LastStatusChangeDate, LastStatusChangeDateGMT,
      Availability, OldAvailability, Comments
    )
    SELECT
      id16_from_counter(v_rsh_start, ROW_NUMBER() OVER(ORDER BY hm.HistoryMainlineId) - 1) AS ResourceStatusHistoryId,
      hm.HistoryMainlineId,
      random_datetime_between(v_start_dt, v_end_dt),
      DATE_SUB(random_datetime_between(v_start_dt, v_end_dt), INTERVAL 9 HOUR),
      FLOOR(RAND()*100), FLOOR(RAND()*100), 'loadtest'
    FROM (
      SELECT HistoryMainlineId
      FROM HistoryMainline
      WHERE TxnDate >= v_start_dt AND TxnDate <= v_end_dt
      ORDER BY HistoryMainlineId
      LIMIT p_rsh
    ) hm;
  END IF;

  /* ===== 6) DataPointHistoryDetail（超巨大：分割バッチ） ===== */
  IF p_dphd > 0 THEN
    DECLARE v_dphd_start BIGINT UNSIGNED;
    DECLARE v_remaining BIGINT;
    DECLARE v_batch BIGINT;

    SET v_remaining = p_dphd;
    SET v_batch = 10000000; -- 1千万行ずつ投入（環境に応じて増減）

    WHILE v_remaining > 0 DO
      DECLARE v_now BIGINT;
      SET v_now = LEAST(v_batch, v_remaining);

      CALL take_id_batch('DataPointHistoryDetail', v_now, v_dphd_start);

      -- DataPointHistory をラウンドロビンで割り当て
      WITH d AS (
        SELECT DataPointHistoryId,
               ROW_NUMBER() OVER(ORDER BY DataPointHistoryId) AS rn,
               (SELECT COUNT(*) FROM DataPointHistory
                WHERE DataPointHistoryId IN (
                  SELECT DataPointHistoryId FROM DataPointHistory dph
                  JOIN HistoryMainline hm ON hm.HistoryMainlineId = dph.HistoryMainlineId
                  WHERE hm.TxnDate >= v_start_dt AND hm.TxnDate <= v_end_dt
                )) AS dtotal
        FROM DataPointHistory dph
        JOIN HistoryMainline hm ON hm.HistoryMainlineId = dph.HistoryMainlineId
        WHERE hm.TxnDate >= v_start_dt AND hm.TxnDate <= v_end_dt
      )
      INSERT INTO DataPointHistoryDetail (
        DataPointHistoryDetailId, DataPointHistoryId, AttributeName, DataName,
        DataType, DataValue, DecimalValue, IntegerValue, TimestampValue,
        IsRequired, IsLimitViolation, IsLimitOverride
      )
      SELECT
        id16_from_counter(v_dphd_start, ROW_NUMBER() OVER(ORDER BY big.n) - 1) AS DataPointHistoryDetailId,
        (SELECT DataPointHistoryId FROM d
         WHERE d.rn = 1 + MOD(ROW_NUMBER() OVER(ORDER BY big.n) - 1, (SELECT dtotal FROM d LIMIT 1))) AS DataPointHistoryId,
        CONCAT('attr_', LPAD(MOD(ROW_NUMBER() OVER(ORDER BY big.n), 1000), 3, '0')) AS AttributeName,
        CONCAT('dn_',   LPAD(MOD(ROW_NUMBER() OVER(ORDER BY big.n), 1000), 3, '0')) AS DataName,
        3 AS DataType, -- 例：Decimal中心
        NULL AS DataValue,
        ROUND(RAND()*1000, 3) AS DecimalValue,
        FLOOR(RAND()*100000) AS IntegerValue,
        random_datetime_between(v_start_dt, v_end_dt) AS TimestampValue,
        1, 0, 0
      FROM (
        -- 1,000 × 10,000 = 10,000,000 相当の行源（下の UNION を調整して v_now を満たす）
        SELECT (a.n*10000 + b.n) AS n
        FROM seq_1k a
        JOIN (
          SELECT n FROM seq_1k WHERE n < 10000
        ) b ON 1=1
      ) big
      LIMIT v_now;

      SET v_remaining = v_remaining - v_now;
      -- 重要：巨大バッチ後の統計更新は月末にまとめてでもOK
    END WHILE;
  END IF;

END$$
DELIMITER ;
```

**3.3 月数を指定して連続生成（表に沿った件数計算）**

```sql
-- nヶ月ぶんを連続生成。件数は仕様表の「1ヶ月あたり」をn倍ではなく、
-- 各月の「追加分」を投入して最終的に累計が表の値に到達。
DROP PROCEDURE IF EXISTS generate_n_months;
DELIMITER $$
CREATE PROCEDURE generate_n_months(IN p_start_month DATE, IN p_months INT)
BEGIN
  DECLARE i INT DEFAULT 1;
  WHILE i <= p_months DO
    -- 1ヶ月分の追加件数（常に一定）
    CALL generate_month(
      DATE_ADD(p_start_month, INTERVAL (i-1) MONTH),
      81,          -- Container
      270270,      -- HistoryMainline
      270270,      -- DataPointHistory
      100000000,   -- DataPointHistoryDetail
      270270,      -- isOEERawDetails
      270270       -- ResourceStatusHistory
    );
    SET i = i + 1;
  END WHILE;
END$$
DELIMITER ;
```

---

# 4) 使い方

```sql
USE loadtest;

-- (初回のみ) マスタが必要なら
CALL seed_masters();

-- 例）2025年1月から 3ヶ月分を連続生成（累計：表の「3ヶ月分」に一致）
CALL generate_n_months('2025-01-01', 3);

-- 例）特定の1ヶ月分だけ（2025年4月）
CALL generate_month('2025-04-01', 81, 270270, 270270, 100000000, 270270, 270270);
```

> 生成完了後は `ANALYZE TABLE` を月末でまとめて実行すると統計が安定します。
> 例：`ANALYZE TABLE HistoryMainline, DataPointHistory, DataPointHistoryDetail, isOEERawDetails, ResourceStatusHistory;`

---

# 5) 運用の要点（重要）

* **パーティション**：

  * `HistoryMainline` / `isOEERawDetails` / `ResourceStatusHistory`：`TxnDate`（または該当日付）で**月次レンジ**。
  * `DataPointHistoryDetail`：`TimestampValue`で**月次レンジ**。
  * 例（新規作成時）：

    ```sql
    PARTITION BY RANGE COLUMNS (TxnDate) (
      PARTITION p202501 VALUES LESS THAN ('2025-02-01'),
      PARTITION p202502 VALUES LESS THAN ('2025-03-01'), ...
    );
    ```
  * 古い月を捨てるときは **`ALTER TABLE ... DROP PARTITION pYYYYMM`** で即時削除。

* **インデックス**：

  * 外部キー列：`HistoryMainline(ContainerId)`, `DataPointHistory(HistoryMainlineId)`, `DataPointHistoryDetail(DataPointHistoryId)`, `isOEERawDetails(HistoryMainlineId)`, `ResourceStatusHistory(HistoryMainlineId)`。
  * 時系列クエリ用：`(TxnDate[, ResourceId/ContainerId])` 複合も検討。

* **性能**：

  * `DataPointHistoryDetail` は **1,000万行×10回/月**の分割投入。必要なら `v_batch` を 5M/20回 や 20M/5回に調整。
  * Cloud SQL のマシンタイプ/ストレージIOPSに応じてトランザクションの大きさをチューニング。
  * 長時間トランザクションを避けるため、**バッチごとコミット**（本スクリプトは INSERT1回=1トランザクション）。

* **安全策**：

  * 専用スキーマ `loadtest` を使用。
  * 本番と混じらないよう**接頭辞/接続先の分離**を徹底。
  * 誤投入時はパーティションDROPで巻き戻し可能。

---

## 仕上げ

* ここまでで、**表の仕様どおり**に月次で増加させるデータ生成を、**MySQLストアドのみ**で実行可能にしました。
* 実テーブルの全列を埋める必要があれば、`INSERT`句に列を追記していけばOKです（負荷試験では**参照/結合で使う列**と**日付/量**が肝です）。

必要なら、\*\*パーティション付きの完全DDL（全列マッピング済み）\*\*も追補します。実環境のMySQLバージョンや既存制約に合わせて最適化も可能です。

---

想定のリレーションを保持したデータができているかを確認したい。
動作確認用のテスト用プロシージャを作成してほしい。
小さいデータ単位にして

---

了解！本番データを汚さず、**指定月だけに小さな検証データを流し込んで自己診断**できるように、次の3つのプロシージャを用意しました。

1. `generate_smoketest_dataset(p_month_start)`
   　…小さな件数（例：Container=3、HM=30、DPH=30、DPHD=10,000、OEE=30、RSH=30）を**その月**にだけ投入。
2. `validate_smoketest_dataset(p_month_start)`
   　…その月に入れたデータに限定して、**リレーションの整合と件数**を総点検（PASS/FAILを返す）。
3. `run_smoketest(p_month_start)`
   　…①→②をまとめて実行。

> 既に前段のユーティリティ（`seq_1k`、`surrogate_counters`、`id16_from_counter`、`take_id_batch`、`random_datetime_between`、`generate_month`）を作成済み前提です。
> スキーマは `loadtest` を使用しています。必要に応じて `USE loadtest;` を付けてください。

---

## 追加プロシージャ（コピペ実行）

```sql
USE loadtest;

-- 1) スモークテスト用の小さなデータ投入
DROP PROCEDURE IF EXISTS generate_smoketest_dataset;
DELIMITER $$
CREATE PROCEDURE generate_smoketest_dataset(IN p_month_start DATE)
BEGIN
  /* 既存データと衝突させないため、月指定で少量だけ投入 */
  CALL generate_month(
    p_month_start,
    3,          -- Container
    30,         -- HistoryMainline
    30,         -- DataPointHistory (HMと1:1)
    10000,      -- DataPointHistoryDetail（1万行）
    30,         -- isOEERawDetails (HMと1:1)
    30          -- ResourceStatusHistory (HMと1:1)
  );
END$$
DELIMITER ;

-- 2) 整合性チェック（その月のデータだけを対象）
DROP PROCEDURE IF EXISTS validate_smoketest_dataset;
DELIMITER $$
CREATE PROCEDURE validate_smoketest_dataset(IN p_month_start DATE)
BEGIN
  DECLARE v_start_dt DATETIME(3);
  DECLARE v_end_dt   DATETIME(3);

  SET v_start_dt = CONCAT(p_month_start, ' 00:00:00.000');
  SET v_end_dt   = CONCAT(LAST_DAY(p_month_start), ' 23:59:59.999');

  /* その月のHMを軸に対象集合を限定 */
  DROP TEMPORARY TABLE IF EXISTS _hm_m;
  CREATE TEMPORARY TABLE _hm_m AS
    SELECT * FROM HistoryMainline
    WHERE TxnDate >= v_start_dt AND TxnDate <= v_end_dt;

  DROP TEMPORARY TABLE IF EXISTS _dph_m;
  CREATE TEMPORARY TABLE _dph_m AS
    SELECT dph.*
    FROM DataPointHistory dph
    JOIN _hm_m hm ON hm.HistoryMainlineId = dph.HistoryMainlineId;

  DROP TEMPORARY TABLE IF EXISTS _dphd_m;
  CREATE TEMPORARY TABLE _dphd_m AS
    SELECT dphd.*
    FROM DataPointHistoryDetail dphd
    JOIN _dph_m dph ON dph.DataPointHistoryId = dphd.DataPointHistoryId;

  DROP TEMPORARY TABLE IF EXISTS _oee_m;
  CREATE TEMPORARY TABLE _oee_m AS
    SELECT oee.*
    FROM isOEERawDetails oee
    JOIN _hm_m hm ON hm.HistoryMainlineId = oee.HistoryMainlineId;

  DROP TEMPORARY TABLE IF EXISTS _rsh_m;
  CREATE TEMPORARY TABLE _rsh_m AS
    SELECT rsh.*
    FROM ResourceStatusHistory rsh
    JOIN _hm_m hm ON hm.HistoryMainlineId = rsh.HistoryMainlineId;

  /* 件数計測 */
  SELECT 'COUNT' AS kind, 'Container (all)' AS target, COUNT(*) AS val FROM Container
  UNION ALL SELECT 'COUNT','HM (month)', COUNT(*) FROM _hm_m
  UNION ALL SELECT 'COUNT','DPH (month)', COUNT(*) FROM _dph_m
  UNION ALL SELECT 'COUNT','DPHD (month)', COUNT(*) FROM _dphd_m
  UNION ALL SELECT 'COUNT','OEE (month)', COUNT(*) FROM _oee_m
  UNION ALL SELECT 'COUNT','RSH (month)', COUNT(*) FROM _rsh_m;

  /* 孤児チェック（外部参照の存在確認） */
  SELECT 'ORPHAN' AS kind, 'HM without Container' AS target, COUNT(*) AS offenders
  FROM _hm_m hm LEFT JOIN Container c ON c.ContainerId = hm.ContainerId
  WHERE c.ContainerId IS NULL

  UNION ALL
  SELECT 'ORPHAN','DPH without HM', COUNT(*)
  FROM _dph_m d LEFT JOIN _hm_m hm ON hm.HistoryMainlineId = d.HistoryMainlineId
  WHERE hm.HistoryMainlineId IS NULL

  UNION ALL
  SELECT 'ORPHAN','DPHD without DPH', COUNT(*)
  FROM _dphd_m dd LEFT JOIN _dph_m d ON d.DataPointHistoryId = dd.DataPointHistoryId
  WHERE d.DataPointHistoryId IS NULL

  UNION ALL
  SELECT 'ORPHAN','OEE without HM', COUNT(*)
  FROM _oee_m o LEFT JOIN _hm_m hm ON hm.HistoryMainlineId = o.HistoryMainlineId
  WHERE hm.HistoryMainlineId IS NULL

  UNION ALL
  SELECT 'ORPHAN','RSH without HM', COUNT(*)
  FROM _rsh_m r LEFT JOIN _hm_m hm ON hm.HistoryMainlineId = r.HistoryMainlineId
  WHERE hm.HistoryMainlineId IS NULL;

  /* 1:1想定の検証（HM↔DPH/OEE/RSH） */
  -- HMごとの件数
  DROP TEMPORARY TABLE IF EXISTS _hm_counts;
  CREATE TEMPORARY TABLE _hm_counts AS
  SELECT
    hm.HistoryMainlineId,
    COALESCE(d.cnt,0)  AS dph_cnt,
    COALESCE(o.cnt,0)  AS oee_cnt,
    COALESCE(r.cnt,0)  AS rsh_cnt
  FROM _hm_m hm
  LEFT JOIN (
    SELECT HistoryMainlineId, COUNT(*) cnt FROM _dph_m GROUP BY HistoryMainlineId
  ) d ON d.HistoryMainlineId = hm.HistoryMainlineId
  LEFT JOIN (
    SELECT HistoryMainlineId, COUNT(*) cnt FROM _oee_m GROUP BY HistoryMainlineId
  ) o ON o.HistoryMainlineId = hm.HistoryMainlineId
  LEFT JOIN (
    SELECT HistoryMainlineId, COUNT(*) cnt FROM _rsh_m GROUP BY HistoryMainlineId
  ) r ON r.HistoryMainlineId = hm.HistoryMainlineId;

  -- 期待＝各1件
  SELECT 'CARDINALITY' AS kind, 'HM with DPH!=1' AS target, COUNT(*) AS offenders
  FROM _hm_counts WHERE dph_cnt <> 1

  UNION ALL
  SELECT 'CARDINALITY','HM with OEE!=1', COUNT(*) FROM _hm_counts WHERE oee_cnt <> 1

  UNION ALL
  SELECT 'CARDINALITY','HM with RSH!=1', COUNT(*) FROM _hm_counts WHERE rsh_cnt <> 1;

  /* DPHDの分布（DPHあたりの明細数） */
  SELECT 'DISTRIBUTION' AS kind,
         'DPHD per DPH (min/avg/max)' AS target,
         CONCAT(
           'min=', MIN(cnt),
           ', avg=', ROUND(AVG(cnt),2),
           ', max=', MAX(cnt)
         ) AS stats
  FROM (
    SELECT DataPointHistoryId, COUNT(*) cnt
    FROM _dphd_m
    GROUP BY DataPointHistoryId
  ) t;

  /* 参考：サンプル結合（5行） */
  SELECT 'SAMPLE_JOIN' AS kind,
         hm.HistoryMainlineId, hm.ContainerId, dph.DataPointHistoryId,
         dd.DataPointHistoryDetailId, oee.isOEERawDetailsId, rsh.ResourceStatusHistoryId
  FROM _hm_m hm
  LEFT JOIN _dph_m dph   ON dph.HistoryMainlineId = hm.HistoryMainlineId
  LEFT JOIN _dphd_m dd   ON dd.DataPointHistoryId = dph.DataPointHistoryId
  LEFT JOIN _oee_m oee   ON oee.HistoryMainlineId = hm.HistoryMainlineId
  LEFT JOIN _rsh_m rsh   ON rsh.HistoryMainlineId = hm.HistoryMainlineId
  LIMIT 5;
END$$
DELIMITER ;

-- 3) 一括実行ラッパー：小規模データ投入→検証
DROP PROCEDURE IF EXISTS run_smoketest;
DELIMITER $$
CREATE PROCEDURE run_smoketest(IN p_month_start DATE)
BEGIN
  CALL generate_smoketest_dataset(p_month_start);
  CALL validate_smoketest_dataset(p_month_start);
END$$
DELIMITER ;
```

---

## 使い方（例）

```sql
USE loadtest;

-- 2025年1月をテスト対象として小規模データ投入→整合性チェック
CALL run_smoketest('2025-01-01');

-- あるいは、投入とチェックを別々に：
CALL generate_smoketest_dataset('2025-02-01');
CALL validate_smoketest_dataset('2025-02-01');
```

### 出力の見方

* 最初の`COUNT`テーブル：その月の HM/DPH/DPHD/OEE/RSH の件数を表示
* `ORPHAN`：親がいないレコード数（0ならOK）
* `CARDINALITY`：1:1想定のズレ（0ならOK）
* `DISTRIBUTION`：DPHあたりのDPHD件数の分布（目安確認）
* `SAMPLE_JOIN`：主要5テーブルの結合サンプル5行

---

必要であれば、**想定件数を引数に取る版**や、**テスト月のデータだけ一括削除するプロシージャ**（パーティション運用なしでも対応）もすぐに追加します。

---

必要であれば、想定件数を引数に取る版や、テスト月のデータだけ一括削除するプロシージャ（パーティション運用なしでも対応）もすぐに追加して

---

了解！パラメータ指定できる版と、「その月だけ一括削除」プロシージャ（非パーティションでもOK）を追加します。既存の `loadtest` スキーマと、これまで作ったユーティリティ/`generate_month` を前提にしています。

---

# 追加プロシージャ（一括コピペでOK）

```sql
USE loadtest;

--------------------------------------------------------------------------------
-- A) 少量データの件数を引数で与えるスモークデータ生成
--------------------------------------------------------------------------------
DROP PROCEDURE IF EXISTS generate_smoketest_dataset_ext;
DELIMITER $$
CREATE PROCEDURE generate_smoketest_dataset_ext(
  IN p_month_start DATE,
  IN p_container INT,
  IN p_hm BIGINT,
  IN p_dph BIGINT,
  IN p_dphd BIGINT,
  IN p_oee BIGINT,
  IN p_rsh BIGINT
)
BEGIN
  CALL generate_month(
    p_month_start,
    p_container,
    p_hm,
    p_dph,
    p_dphd,
    p_oee,
    p_rsh
  );
END$$
DELIMITER ;

-- 使い勝手の良いラッパ：デフォルトは小さめ
DROP PROCEDURE IF EXISTS run_smoketest_ext;
DELIMITER $$
CREATE PROCEDURE run_smoketest_ext(
  IN p_month_start DATE,
  IN p_container INT DEFAULT 3,
  IN p_hm BIGINT  DEFAULT 30,
  IN p_dph BIGINT DEFAULT 30,
  IN p_dphd BIGINT DEFAULT 10000,
  IN p_oee BIGINT DEFAULT 30,
  IN p_rsh BIGINT DEFAULT 30
)
BEGIN
  CALL generate_smoketest_dataset_ext(p_month_start, p_container, p_hm, p_dph, p_dphd, p_oee, p_rsh);
  CALL validate_smoketest_dataset(p_month_start);
END$$
DELIMITER ;

--------------------------------------------------------------------------------
-- B) 指定月データの一括削除（パーティション無しでも安全に月単位で削除）
--    方針：
--     1) 対象月のHistoryMainline ID集合を確定
--     2) それに紐づく DataPointHistory → DataPointHistoryDetail → isOEERawDetails → ResourceStatusHistory の順で削除
--     3) 最後に HistoryMainline を削除
--     4) Container は「その月に作られ」かつ「もう参照されない」ものだけ削除（安全側）
--------------------------------------------------------------------------------
DROP PROCEDURE IF EXISTS delete_test_month;
DELIMITER $$
CREATE PROCEDURE delete_test_month(IN p_month_start DATE)
BEGIN
  DECLARE v_start_dt DATETIME(3);
  DECLARE v_end_dt   DATETIME(3);

  SET v_start_dt = CONCAT(p_month_start, ' 00:00:00.000');
  SET v_end_dt   = CONCAT(LAST_DAY(p_month_start), ' 23:59:59.999');

  /* 1) 対象集合の一時表 */
  DROP TEMPORARY TABLE IF EXISTS _hm_m;
  CREATE TEMPORARY TABLE _hm_m
    (PRIMARY KEY (HistoryMainlineId))
  AS
    SELECT HistoryMainlineId, ContainerId
    FROM HistoryMainline
    WHERE TxnDate >= v_start_dt AND TxnDate <= v_end_dt;

  DROP TEMPORARY TABLE IF EXISTS _dph_m;
  CREATE TEMPORARY TABLE _dph_m
    (PRIMARY KEY (DataPointHistoryId))
  AS
    SELECT dph.DataPointHistoryId
    FROM DataPointHistory dph
    JOIN _hm_m hm ON hm.HistoryMainlineId = dph.HistoryMainlineId;

  /* 2) 子→親の順で削除（件数を返す） */
  -- 2-1) DataPointHistoryDetail
  SELECT COUNT(*) AS will_delete_dphd FROM DataPointHistoryDetail WHERE DataPointHistoryId IN (SELECT DataPointHistoryId FROM _dph_m);
  DELETE dphd FROM DataPointHistoryDetail dphd
  JOIN _dph_m d ON d.DataPointHistoryId = dphd.DataPointHistoryId;

  -- 2-2) isOEERawDetails
  SELECT COUNT(*) AS will_delete_oee FROM isOEERawDetails WHERE HistoryMainlineId IN (SELECT HistoryMainlineId FROM _hm_m);
  DELETE oee FROM isOEERawDetails oee
  JOIN _hm_m hm ON hm.HistoryMainlineId = oee.HistoryMainlineId;

  -- 2-3) ResourceStatusHistory
  SELECT COUNT(*) AS will_delete_rsh FROM ResourceStatusHistory WHERE HistoryMainlineId IN (SELECT HistoryMainlineId FROM _hm_m);
  DELETE rsh FROM ResourceStatusHistory rsh
  JOIN _hm_m hm ON hm.HistoryMainlineId = rsh.HistoryMainlineId;

  -- 2-4) DataPointHistory
  SELECT COUNT(*) AS will_delete_dph FROM DataPointHistory WHERE DataPointHistoryId IN (SELECT DataPointHistoryId FROM _dph_m);
  DELETE dph FROM DataPointHistory dph
  JOIN _dph_m d ON d.DataPointHistoryId = dph.DataPointHistoryId;

  -- 2-5) HistoryMainline
  SELECT COUNT(*) AS will_delete_hm FROM HistoryMainline WHERE HistoryMainlineId IN (SELECT HistoryMainlineId FROM _hm_m);
  DELETE hm FROM HistoryMainline hm
  JOIN _hm_m t ON t.HistoryMainlineId = hm.HistoryMainlineId;

  /* 3) Container の後始末
        ・その月に作成された（ManufacturingDateが該当月）
        ・かつ もう HistoryMainline に参照されていない
        もののみ削除（他月のHMが残っているContainerは温存） */
  DROP TEMPORARY TABLE IF EXISTS _c_m;
  CREATE TEMPORARY TABLE _c_m
    (PRIMARY KEY (ContainerId))
  AS
    SELECT c.ContainerId
    FROM Container c
    WHERE c.ManufacturingDate >= v_start_dt
      AND c.ManufacturingDate <= v_end_dt;

  -- 参照が残っていないコンテナのみ削除
  SELECT COUNT(*) AS will_delete_containers
  FROM Container c
  JOIN _c_m cm ON cm.ContainerId = c.ContainerId
  LEFT JOIN HistoryMainline hm ON hm.ContainerId = c.ContainerId
  WHERE hm.ContainerId IS NULL;

  DELETE c FROM Container c
  JOIN _c_m cm ON cm.ContainerId = c.ContainerId
  LEFT JOIN HistoryMainline hm ON hm.ContainerId = c.ContainerId
  WHERE hm.ContainerId IS NULL;

  /* 4) 参考：残件数を返す */
  SELECT 'REMAINING' AS kind, 'Container', COUNT(*) AS cnt FROM Container
  UNION ALL SELECT 'REMAINING','HistoryMainline', COUNT(*) FROM HistoryMainline
  UNION ALL SELECT 'REMAINING','DataPointHistory', COUNT(*) FROM DataPointHistory
  UNION ALL SELECT 'REMAINING','DataPointHistoryDetail', COUNT(*) FROM DataPointHistoryDetail
  UNION ALL SELECT 'REMAINING','isOEERawDetails', COUNT(*) FROM isOEERawDetails
  UNION ALL SELECT 'REMAINING','ResourceStatusHistory', COUNT(*) FROM ResourceStatusHistory;
END$$
DELIMITER ;
```

---

## 使い方の例

```sql
-- 1) 件数を指定して小さなデータを投入→検証
CALL run_smoketest_ext('2025-03-01', 5, 50, 50, 20000, 50, 50);

-- 2) その月のデータだけを一括削除（非パーティション環境でもOK）
CALL delete_test_month('2025-03-01');

-- 3) 既存の固定件数版もこれまで通り利用可
CALL run_smoketest('2025-01-01');
```

---

## 補足（実運用のヒント）

* DELETEは大きくなりがちなので、巨大月で使う場合は

  * ①テーブルごとに `WHERE ... LIMIT N` を刻むバージョン、
  * ②`FOREIGN KEY ... ON DELETE CASCADE` の併用、
  * ③月次パーティション運用なら `ALTER TABLE ... DROP PARTITION`
    もご検討ください（今回はFK未定義前提の手動順序削除にしています）。
* `delete_test_month` は **該当月に生成された Container のみ**消そうとします。他月データから参照される可能性のあるContainerは残す安全設計です。

必要があれば、**バッチサイズ指定の段階削除版**や、**FK＋CASCADE対応版**、**パーティションDROP版**もすぐ出せます。

---
