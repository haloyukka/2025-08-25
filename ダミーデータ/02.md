了解です。MS SQL Server 前提で、**連番ID（`char(16)`）**、**月次削除は `HistoryMainline.systemdate` 基準**、**Container はまず 81 件**、**FK は張らない**、\*\*分布は一様（JST）\*\*で進めます。

下記の「そのまま実行できる T-SQL 一式」をお渡しします。

* 既存の `Container` テーブルはそのまま使い、**NOT NULL 列（bit など）も埋めます**。
* `HistoryMainline` ほかは **最小カラムの暫定テーブル**を「なければ作成」します（既存定義がある場合は作られません）。
* 生成パラメータは **プロシージャ引数**で調整可能（デフォルトは Container=81件、1コンテナあたりの履歴=10、など）。
* **削除SP**は `YYYY-MM` 指定で、子→親の順に消します（FKなしでも安全）。
* **チェックSP**で件数と孤児の有無を確認できます。

---

# そのまま使える T-SQL 一式

```sql
/* ===========================================
   0) 作業DB（暫定）
=========================================== */
IF DB_ID(N'perf_test') IS NULL
BEGIN
  CREATE DATABASE perf_test;
END
GO
USE perf_test;
GO

/* ===========================================
   1) 連番を char(16) にゼロ詰め整形する関数
      例) 1 -> '0000000000000001'
=========================================== */
IF OBJECT_ID(N'dbo.fn_seq_char16', N'FN') IS NOT NULL
  DROP FUNCTION dbo.fn_seq_char16;
GO
CREATE FUNCTION dbo.fn_seq_char16(@n BIGINT)
RETURNS CHAR(16)
AS
BEGIN
  RETURN RIGHT(REPLICATE('0',16) + CONVERT(VARCHAR(32), @n), 16);
END
GO

/* ===========================================
   2) JST 現在時刻を datetime で返す関数
      （タイムゾーンは 'Tokyo Standard Time'）
=========================================== */
IF OBJECT_ID(N'dbo.fn_now_jst', N'FN') IS NOT NULL
  DROP FUNCTION dbo.fn_now_jst;
GO
CREATE FUNCTION dbo.fn_now_jst()
RETURNS DATETIME
AS
BEGIN
  RETURN CONVERT(DATETIME, SYSDATETIMEOFFSET() AT TIME ZONE 'Tokyo Standard Time');
END
GO

/* ===========================================
   3) 暫定テーブル（存在しなければ作成）
      ※ 既存環境に列が足りない場合は、この暫定定義に合わせて
         プロシージャ内の INSERT 対象列を調整してください
=========================================== */

-- HistoryMainline（最小構成）
IF OBJECT_ID(N'dbo.HistoryMainline', N'U') IS NULL
BEGIN
  CREATE TABLE dbo.HistoryMainline(
    HistoryMainlineId  CHAR(16) NOT NULL PRIMARY KEY,
    ContainerId        CHAR(16) NOT NULL,
    systemdate         DATETIME NOT NULL
    -- 必要に応じて列を追加可能
  );
END

-- DataPointHistory（最小構成）
IF OBJECT_ID(N'dbo.DataPointHistory', N'U') IS NULL
BEGIN
  CREATE TABLE dbo.DataPointHistory(
    DataPointHistoryId  CHAR(16) NOT NULL PRIMARY KEY,
    HistoryMainlineId   CHAR(16) NOT NULL
  );
END

-- DataPointHistoryDetail（最小構成）
IF OBJECT_ID(N'dbo.DataPointHistoryDetail', N'U') IS NULL
BEGIN
  CREATE TABLE dbo.DataPointHistoryDetail(
    DataPointHistoryDetailId CHAR(16) NOT NULL PRIMARY KEY,
    DataPointHistoryId       CHAR(16) NOT NULL
  );
END

-- isOEERawDetails（最小構成）
IF OBJECT_ID(N'dbo.isOEERawDetails', N'U') IS NULL
BEGIN
  CREATE TABLE dbo.isOEERawDetails(
    isOEERawDetailsId  CHAR(16) NOT NULL PRIMARY KEY,
    HistoryMainlineId  CHAR(16) NOT NULL
  );
END

-- ResourceStatusHistory（最小構成）
IF OBJECT_ID(N'dbo.ResourceStatusHistory', N'U') IS NULL
BEGIN
  CREATE TABLE dbo.ResourceStatusHistory(
    ResourceStatusHistoryId CHAR(16) NOT NULL PRIMARY KEY,
    HistoryMainlineId       CHAR(16) NOT NULL
  );
END
GO

/* ===========================================
   4) コンテナ投入 SP
   - 既存 Container テーブルを使用
   - NOT NULL の bit 列をすべて埋める
   - 連番ID（char(16)）で分かりやすく
   - 日付は JST で一様ランダム
=========================================== */
IF OBJECT_ID(N'dbo.sp_seed_containers', N'P') IS NOT NULL
  DROP PROCEDURE dbo.sp_seed_containers;
GO
CREATE PROCEDURE dbo.sp_seed_containers
  @container_count INT = 81,             -- 生成件数
  @start_date DATE = NULL,               -- 期間開始（NULLなら今日）
  @days INT = 7                          -- 生成する日数（@start_date から @days 日）
AS
BEGIN
  SET NOCOUNT ON;

  IF @start_date IS NULL
    SET @start_date = CONVERT(DATE, dbo.fn_now_jst());

  DECLARE @i INT = 1;

  WHILE @i <= @container_count
  BEGIN
    DECLARE @id CHAR(16) = dbo.fn_seq_char16(@i);
    DECLARE @d  DATETIME = DATEADD(SECOND, ABS(CHECKSUM(NEWID())) % 86400, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % @days, @start_date));
    DECLARE @dJ DATETIME = @d; -- JST として扱う

    /* Container へ最低限 + NOT NULL 列を INSERT
       ※ ここで指定していない列は NULL を許容する前提（元DDL準拠）
       ※ NOT NULL の bit 列は 0/1 を設定
    */
    INSERT INTO dbo.Container(
      ContainerId, ContainerName, BatchId, BatchStatus, CurrentStatusId, CustomerId,
      MfgOrderId, ProductId, Qty, UnitCount,
      FactoryStartDate, FactoryStartDateGMT, LastActivityDate, LastActivityDateGMT,
      PlannedStartDate, PlannedStartDateGMT,
      ProductionComplete, SamplingPassed, SamplingRequired, ThisContainerLost,
      bpCalculateQtyRequired, isAutoStart, isCarrier, isFailed, isMaterialManageEnabled,
      Description, NickName, ShapeName
    ) VALUES (
      @id, CONCAT('C_', @id), dbo.fn_seq_char16(100000+@i), ABS(CHECKSUM(NEWID())) % 5, dbo.fn_seq_char16(200000+@i), dbo.fn_seq_char16(300000+@i),
      dbo.fn_seq_char16(400000+@i), dbo.fn_seq_char16(500000+@i), 1.0 + (@i % 100), 1 + (@i % 20),
      @dJ, @dJ, DATEADD(HOUR, 1, @dJ), DATEADD(HOUR, 1, @dJ),
      DATEADD(HOUR, -2, @dJ), DATEADD(HOUR, -2, @dJ),
      CASE WHEN (@i % 3)=0 THEN 1 ELSE 0 END,  -- ProductionComplete
      1,                                       -- SamplingPassed
      CASE WHEN (@i % 2)=0 THEN 1 ELSE 0 END,  -- SamplingRequired
      0,                                       -- ThisContainerLost
      1,                                       -- bpCalculateQtyRequired
      CASE WHEN (@i % 5)=0 THEN 1 ELSE 0 END,  -- isAutoStart
      CASE WHEN (@i % 10)=0 THEN 1 ELSE 0 END, -- isCarrier
      0,                                       -- isFailed
      1,                                       -- isMaterialManageEnabled
      N'dummy container for perf test', CONCAT(N'Nick_', @i), N'Box'
    );

    SET @i += 1;
  END
END
GO

/* ===========================================
   5) 親子データ一括生成 SP
   - Container（既存）に紐づけて HistoryMainline などを生成
   - 連番 char(16) でわかりやすく
   - 分布は一様（@start_date ～ @days）
=========================================== */
IF OBJECT_ID(N'dbo.sp_seed_mainline_and_children', N'P') IS NOT NULL
  DROP PROCEDURE dbo.sp_seed_mainline_and_children;
GO
CREATE PROCEDURE dbo.sp_seed_mainline_and_children
  @histories_per_container INT = 10,
  @datapoints_per_history  INT = 3,
  @details_per_datapoint   INT = 5,
  @oee_per_history         INT = 2,
  @resource_per_history    INT = 1,
  @start_date DATE = NULL,
  @days INT = 7
AS
BEGIN
  SET NOCOUNT ON;

  IF @start_date IS NULL
    SET @start_date = CONVERT(DATE, dbo.fn_now_jst());

  DECLARE @h BIGINT = 1, @p BIGINT = 1, @pd BIGINT = 1, @oee BIGINT = 1, @rs BIGINT = 1;

  DECLARE cur CURSOR LOCAL FAST_FORWARD FOR
    SELECT ContainerId FROM dbo.Container ORDER BY ContainerId;

  DECLARE @cid CHAR(16);
  OPEN cur;
  FETCH NEXT FROM cur INTO @cid;

  WHILE @@FETCH_STATUS = 0
  BEGIN
    DECLARE @k INT = 1;
    WHILE @k <= @histories_per_container
    BEGIN
      DECLARE @hid CHAR(16) = dbo.fn_seq_char16(@h);
      DECLARE @sd  DATETIME = DATEADD(SECOND, ABS(CHECKSUM(NEWID())) % 86400,
                                      DATEADD(DAY, ABS(CHECKSUM(NEWID())) % @days, @start_date));
      -- HistoryMainline
      INSERT INTO dbo.HistoryMainline(HistoryMainlineId, ContainerId, systemdate)
      VALUES(@hid, @cid, @sd);

      -- DataPointHistory（@datapoints_per_history 件）
      DECLARE @i INT = 1;
      WHILE @i <= @datapoints_per_history
      BEGIN
        DECLARE @pid CHAR(16) = dbo.fn_seq_char16(@p);
        INSERT INTO dbo.DataPointHistory(DataPointHistoryId, HistoryMainlineId)
        VALUES(@pid, @hid);

        -- DataPointHistoryDetail（@details_per_datapoint 件）
        DECLARE @j INT = 1;
        WHILE @j <= @details_per_datapoint
        BEGIN
          DECLARE @pdid CHAR(16) = dbo.fn_seq_char16(@pd);
          INSERT INTO dbo.DataPointHistoryDetail(DataPointHistoryDetailId, DataPointHistoryId)
          VALUES(@pdid, @pid);
          SET @pd += 1;
          SET @j  += 1;
        END

        SET @p += 1;
        SET @i += 1;
      END

      -- isOEERawDetails（@oee_per_history 件）
      DECLARE @o INT = 1;
      WHILE @o <= @oee_per_history
      BEGIN
        DECLARE @oid CHAR(16) = dbo.fn_seq_char16(@oee);
        INSERT INTO dbo.isOEERawDetails(isOEERawDetailsId, HistoryMainlineId)
        VALUES(@oid, @hid);
        SET @oee += 1;
        SET @o   += 1;
      END

      -- ResourceStatusHistory（@resource_per_history 件）
      DECLARE @r INT = 1;
      WHILE @r <= @resource_per_history
      BEGIN
        DECLARE @rid CHAR(16) = dbo.fn_seq_char16(@rs);
        INSERT INTO dbo.ResourceStatusHistory(ResourceStatusHistoryId, HistoryMainlineId)
        VALUES(@rid, @hid);
        SET @rs += 1;
        SET @r  += 1;
      END

      SET @h += 1;
      SET @k += 1;
    END

    FETCH NEXT FROM cur INTO @cid;
  END

  CLOSE cur;
  DEALLOCATE cur;
END
GO

/* ===========================================
   6) 月次削除（HistoryMainline.systemdate 基準）
      子 → 親 の順で DELETE
      形式: 'YYYY-MM'
=========================================== */
IF OBJECT_ID(N'dbo.sp_delete_by_month', N'P') IS NOT NULL
  DROP PROCEDURE dbo.sp_delete_by_month;
GO
CREATE PROCEDURE dbo.sp_delete_by_month
  @ym CHAR(7)  -- 'YYYY-MM'
AS
BEGIN
  SET NOCOUNT ON;

  DECLARE @from DATE = CONVERT(DATE, @ym + '-01');
  DECLARE @to   DATE = DATEADD(MONTH, 1, @from);

  ;WITH m AS (
    SELECT HistoryMainlineId
    FROM dbo.HistoryMainline
    WHERE systemdate >= @from AND systemdate < @to
  )
  -- 子テーブル削除
  DELETE dphd
    FROM dbo.DataPointHistoryDetail dphd
    WHERE EXISTS (
      SELECT 1 FROM dbo.DataPointHistory dph
      JOIN m ON m.HistoryMainlineId = dph.HistoryMainlineId
      WHERE dphd.DataPointHistoryId = dph.DataPointHistoryId
    );

  DELETE dph
    FROM dbo.DataPointHistory dph
    JOIN m ON m.HistoryMainlineId = dph.HistoryMainlineId;

  DELETE oee
    FROM dbo.isOEERawDetails oee
    JOIN m ON m.HistoryMainlineId = oee.HistoryMainlineId;

  DELETE rs
    FROM dbo.ResourceStatusHistory rs
    JOIN m ON m.HistoryMainlineId = rs.HistoryMainlineId;

  -- 親削除
  DELETE hm
    FROM dbo.HistoryMainline hm
    WHERE hm.systemdate >= @from AND hm.systemdate < @to;
END
GO

/* ===========================================
   7) サニティチェック（件数/孤児検知/日次集計）
=========================================== */
IF OBJECT_ID(N'dbo.sp_check_sanity', N'P') IS NOT NULL
  DROP PROCEDURE dbo.sp_check_sanity;
GO
CREATE PROCEDURE dbo.sp_check_sanity
AS
BEGIN
  SET NOCOUNT ON;

  -- 件数ざっくり
  SELECT
    (SELECT COUNT(*) FROM dbo.Container)              AS cnt_container,
    (SELECT COUNT(*) FROM dbo.HistoryMainline)        AS cnt_history_mainline,
    (SELECT COUNT(*) FROM dbo.DataPointHistory)       AS cnt_data_point_history,
    (SELECT COUNT(*) FROM dbo.DataPointHistoryDetail) AS cnt_data_point_history_detail,
    (SELECT COUNT(*) FROM dbo.isOEERawDetails)        AS cnt_is_oee_raw_details,
    (SELECT COUNT(*) FROM dbo.ResourceStatusHistory)  AS cnt_resource_status_history;

  -- HistoryMainline 日次件数（直近14日）
  SELECT CAST(systemdate AS DATE) AS d, COUNT(*) AS cnt
  FROM dbo.HistoryMainline
  WHERE systemdate >= DATEADD(DAY, -14, CONVERT(DATE, dbo.fn_now_jst()))
  GROUP BY CAST(systemdate AS DATE)
  ORDER BY d;

  -- 孤児（論理整合チェック）
  SELECT 'HistoryMainline without Container' AS issue, COUNT(*) AS n
  FROM dbo.HistoryMainline h
  WHERE NOT EXISTS (SELECT 1 FROM dbo.Container c WHERE c.ContainerId = h.ContainerId);

  SELECT 'DataPointHistory without HistoryMainline' AS issue, COUNT(*) AS n
  FROM dbo.DataPointHistory p
  WHERE NOT EXISTS (SELECT 1 FROM dbo.HistoryMainline h WHERE h.HistoryMainlineId = p.HistoryMainlineId);

  SELECT 'DataPointHistoryDetail without DataPointHistory' AS issue, COUNT(*) AS n
  FROM dbo.DataPointHistoryDetail d
  WHERE NOT EXISTS (SELECT 1 FROM dbo.DataPointHistory p WHERE p.DataPointHistoryId = d.DataPointHistoryId);

  SELECT 'isOEERawDetails without HistoryMainline' AS issue, COUNT(*) AS n
  FROM dbo.isOEERawDetails o
  WHERE NOT EXISTS (SELECT 1 FROM dbo.HistoryMainline h WHERE h.HistoryMainlineId = o.HistoryMainlineId);

  SELECT 'ResourceStatusHistory without HistoryMainline' AS issue, COUNT(*) AS n
  FROM dbo.ResourceStatusHistory r
  WHERE NOT EXISTS (SELECT 1 FROM dbo.HistoryMainline h WHERE h.HistoryMainlineId = r.HistoryMainlineId);
END
GO
```

---

## 実行例（そのままコピペOK）

```sql
USE perf_test;
GO

-- 1) まず 81 件の Container を投入（7日間にランダム散らし）
EXEC dbo.sp_seed_containers
  @container_count = 81,
  @start_date = '2025-08-01',
  @days = 7;

-- 2) 親子データをまとめて生成
EXEC dbo.sp_seed_mainline_and_children
  @histories_per_container = 10,
  @datapoints_per_history  = 3,
  @details_per_datapoint   = 5,
  @oee_per_history         = 2,
  @resource_per_history    = 1,
  @start_date = '2025-08-01',
  @days = 7;

-- 3) サニティチェック
EXEC dbo.sp_check_sanity;

-- 4) 2025-08 のデータを一括削除（HistoryMainline.systemdate 基準）
EXEC dbo.sp_delete_by_month @ym = '2025-08';
```

---

## 補足（設計のポイント）

* **IDは連番の可視性重視**で `fn_seq_char16(n)` を採用（`000...0001` 形式）。
* **Timezone は JST**：`fn_now_jst()` を用意（生成時刻の基準に利用）。
* **FK は未設定**のため、整合は `sp_check_sanity` で検知（実運用で必要ならインデックスだけ追加を推奨）。
* **既存 Container DDL の NOT NULL(bit) 列**は確実に埋めるように INSERT しています。
* **既存テーブルがある場合**：暫定テーブルの `IF NOT EXISTS` ブロックはスキップされます。既存定義に必須列が多い場合は、`sp_seed_mainline_and_children` 内の INSERT 対象列を追加してください。

---

このまま動かしてみてください。
「履歴件数をもっと増やしたい」「Details を 0 にして軽くしたい」「月次削除を複数月に対応したい」など、要望があれば即座に反映した改訂版をお渡しします。
